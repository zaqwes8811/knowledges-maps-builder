# coding: utf-8
# regenerator_python_code
import os
import dals.os_io.io_wrapper as iow

template = 'package org.jython.book.util;\n'+ \
    '\n'+ \
    'import org.jython.book.interfaces.BuildingType;\n'+ \
    '\n'+ \
    'import org.python.core.PyObject;\n'+ \
    'import org.python.core.PyString;\n'+ \
    'import org.python.util.PythonInterpreter;\n'+ \
    '\n'+ \
    'public class BuildingFactory {\n'+ \
    '\n'+ \
    '  private PyObject buildingClass;\n'+ \
    '\n'+ \
    '  /**\n'+ \
    '   * Create a new PythonInterpreter object, then use it to\n'+ \
    '   * execute some python code. In this case, we want to\n'+ \
    '   * import the python module that we will coerce.\n'+ \
    '   *\n'+ \
    '   * Once the module is imported than we obtain a reference to\n'+ \
    '   * it and assign the reference to a Java variable\n'+ \
    '   */\n'+ \
    '\n'+ \
    '  public BuildingFactory() {\n'+ \
    '    PythonInterpreter interpreter = new PythonInterpreter();\n'+ \
    '    interpreter.exec("import sys");\n'+ \
    '    interpreter.exec("sys.path.append(\'D:/github/content-translate-assistant/src/org/jython/book/interfaces\')");\n'+ \
    '    interpreter.exec("from Building import Building");\n'+ \
    '    buildingClass = interpreter.get("Building");\n'+ \
    '  }\n'+ \
    '\n'+ \
    '  /**\n'+ \
    '   * The create method is responsible for performing the actual\n'+ \
    '   * coercion of the referenced python module into Java bytecode\n'+ \
    '   */\n'+ \
    '\n'+ \
    '  public BuildingType create() {\n'+ \
    '\n'+ \
    '    PyObject buildingObject = buildingClass.__call__();\n'+ \
    '    return (BuildingType)buildingObject.__tojava__(BuildingType.class);\n'+ \
    '  }\n'+ \
    '}'


def _to_java_notation(sentence):
    result_string = ''
    space_was = False
    for at in sentence:
        if at != '_':
            if space_was:
                result_string += at.upper()
                space_was = False
            else:
                result_string += at
        else:
            space_was = True
    return result_string

def _to_java_notation_python_method_header(header):
    tmp = header.replace('def ', '(')
    save_method_name = tmp.split('(')[1]
    new_method_name = _to_java_notation(save_method_name)
    
    tmp = header.replace(save_method_name, new_method_name)
    return tmp 

def _get_public_class_headers(at):
    tmp = at.replace('class ','').split('(')[0]

    jheader = 'public interface I'+tmp+' {'
    pheader = 'class '+tmp+'(I'+tmp+'):'
    
    return jheader, pheader, 'I'+tmp

def get_file_content(fname):
    sets = iow.get_utf8_template()
    sets['name'] = fname
    source_content = iow.file2list(sets)
    return source_content
    
def write_source(fname, list_lines):
    sets = iow.get_utf8_template()
    sets['name'] = fname
    sets['howOpen'] = 'w'
    iow.list2file(sets, list_lines)

def generate_python_code(source_content):
    # FOR Python
    header = ''
    result_python_iface_source = ['# Autogenerated']
    for at in source_content:
        # Выделяем открытые методы
        if 'def _' not in at and 'self' in at and 'def' in at:
            method = _to_java_notation_python_method_header(at)
            result_python_iface_source.append(method)
    
        # Выделяем главный класс
        elif '#public' in at:
            j, p, header = _get_public_class_headers(at)
            result_python_iface_source.append(p)
        else:
            result_python_iface_source.append(at)  
            
    result_python_iface_source.insert(2, 'import '+header)
    write_source(header[1:]+'.py', result_python_iface_source)

def generate_java_code(source_content):  
    # FOR Java  
    header = ''
    result_java_iface_source = ['// Autogenerated']
    list_for_import = set()
    for at in source_content:
        # Выделяем открытые методы
        if 'def _' not in at and 'self' in at and 'def' in at:
            src_name = at[8:]
            src_name = src_name.replace(':','')
            splitted = src_name.split('#')
            src_name = splitted[1]+' '+splitted[0]+';'
            
            # In params
            src_name = src_name.replace('list_s_', 'List<String> ')
            src_name = src_name.replace('str_', 'String ')
            
            # returns
            src_name = src_name.replace('list', 'List')
            src_name = src_name.replace('map<', 'Map<')
            src_name = src_name.replace('string', 'String')
            src_name = src_name.replace('int', 'Integer')
            src_name = src_name.replace('self, ', '')
            src_name = src_name.replace('self', '')
           
            src_name = _to_java_notation(src_name)
            result_java_iface_source.append('  '+src_name)
            
            # Длы импотра старнартынх модулей
            if 'List' in src_name:
                list_for_import.add('import java.util.List;')
            if 'Map' in src_name:
                list_for_import.add('import java.util.Map;')
                    
        # Выделяем главный класс
        elif '#public' in at:
            j, p, header = _get_public_class_headers(at)
            result_java_iface_source.append(j)
        else:
            pass
                  
    result_java_iface_source.append('}')

    # FOR Java
    path = os.getcwd()
    path = path.replace('\\', '@@@')[2+3:]  # убираем букву тома
    pkgs_path = path.split('@@@')
    package_path = 'package '
    pkgs_list = []
    for at in reversed(pkgs_path):
        if '-' not in at:
            pkgs_list.append(at)
        else:
            break
      
    result_pkg_list = []
    for at in reversed(pkgs_list):
        result_pkg_list.append(at)

    package_path += '.'.join(result_pkg_list[1:])
    result_java_iface_source.insert(1, package_path+';\n')
    
    for at in list_for_import:
        result_java_iface_source.insert(2, at)
    
    write_source(header+'.java', result_java_iface_source)
    
    # Теперь нужно сгенерировать фабрику по производству объектов
    tmp = template.replace(
            'package org.jython.book.util;', 
            package_path+';')  
    tmp = tmp.replace(
            'import org.jython.book.interfaces.BuildingType;', 
            'import '+package_path.replace('package ', '')+'.'+header+';') 
    
    tmp = tmp.replace('BuildingFactory', header[1:]+'Factory')
    
    tmp = tmp.replace('BuildingType', header) 
    tmp = tmp.replace('Building', header[1:])
    tmp = tmp.replace('D:/github/content-translate-assistant/src/org/jython/book/interfaces', os.getcwd().replace('\\','/'))
    
    write_source(header[1:]+'Factory'+'.java', [tmp])
    
if __name__=='__main__':
    source_content = get_file_content('orginator.py')
    generate_python_code(source_content)
    generate_java_code(source_content)

